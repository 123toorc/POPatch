diff -uprN 4.14.79/include/linux/bcm_iproc_dte.h 4.14.79_popcorn/include/linux/bcm_iproc_dte.h
--- 4.14.79/include/linux/bcm_iproc_dte.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/linux/bcm_iproc_dte.h	2020-05-24 22:41:30.646905819 -0400
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#ifndef _BCM_IPROC_DTE_H_
+#define _BCM_IPROC_DTE_H_
+
+#include <linux/cdev.h>
+#include <linux/kfifo.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+
+struct dte_user_info {
+	struct file *fp; /* File opened by user */
+	bool internal_user;
+	wait_queue_head_t ts_wait_queue;
+};
+
+struct dte_client_mapping {
+	u32 client_index;
+	u32 lts_index;
+	u32 reg_offset;
+	u32 shift;
+	char *name;
+	u32 div_status;
+};
+
+struct bcm_dte {
+	struct platform_device *pdev;
+	struct cdev dte_cdev;
+	struct class *dte_class;
+	struct kfifo *recv_fifo;
+	int irq;
+	dev_t devt;
+	uint32_t fifoof;
+	uint32_t fifouf;
+	uint32_t *kfifoof;
+	uint32_t src_ena;
+	spinlock_t lock;
+	struct mutex en_ts_lock;
+	struct mutex mutex;
+	struct timespec ts_ref;
+	uint32_t timestamp_overflow_last;
+	void __iomem *audioeav;
+	void __iomem *trigg_reg;
+
+	uint32_t irq_interval_ns;
+	uint32_t usr_cnt; /* tracks num of users */
+	struct dte_user_info *user;
+	struct timer_list fifo_timer;
+	struct timer_list ovf_timer;
+	unsigned int num_of_clients;
+	struct dte_client_mapping *dte_cli;
+	uint32_t nco_susp_val;
+	uint32_t trigg_reg_susp_val;
+
+	int (*enable_ts)(struct bcm_dte *dte,
+		unsigned int client, bool enable,
+		uint32_t divider, bool both_edge, struct file *fp);
+	int (*get_ts)(struct bcm_dte *dte,
+		unsigned int client, struct timespec *ts);
+
+	int (*nco_set_time)(struct bcm_dte *dte, struct timespec *ts);
+	int (*nco_get_time)(struct bcm_dte *dte, struct timespec *ts);
+	int (*nco_adj_time)(struct bcm_dte *dte, int64_t delta);
+	int (*nco_adj_freq)(struct bcm_dte *dte, int32_t ppb);
+	int (*nco_get_freq_adj)(struct bcm_dte *dte, int32_t *ppb);
+};
+
+#endif
diff -uprN 4.14.79/include/linux/bcm_iproc_mailbox.h 4.14.79_popcorn/include/linux/bcm_iproc_mailbox.h
--- 4.14.79/include/linux/bcm_iproc_mailbox.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/linux/bcm_iproc_mailbox.h	2020-05-24 22:41:30.646905819 -0400
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Broadcom.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _BCM_IPROC_MAILBOX_H_
+#define _BCM_IPROC_MAILBOX_H_
+
+#include <linux/types.h>
+/*
+ * A message to send to the M0 processor.
+ * @cmd Command to send.
+ * @param Parameter corresponding to command.
+ * @wait_ack true if mbox_send_message() should wait for a reply from the M0,
+ *   false if the M0 doesn't reply. This depends on the message being sent.
+ * @reply_code The response code from the M0 for the command sent (wait_ack was
+ *   set to true).
+ */
+struct iproc_mbox_msg {
+	u32       cmd;
+	u32       param;
+	bool      wait_ack;
+	u32       reply_code;
+};
+
+#endif
diff -uprN 4.14.79/include/linux/brcmphy.h 4.14.79_popcorn/include/linux/brcmphy.h
--- 4.14.79/include/linux/brcmphy.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/brcmphy.h	2020-05-24 22:41:30.650905805 -0400
@@ -19,6 +19,7 @@
 #define PHY_ID_BCM5411			0x00206070
 #define PHY_ID_BCM5421			0x002060e0
 #define PHY_ID_BCM54210E		0x600d84a0
+#define PHY_ID_BCM54210S		0x600d8590
 #define PHY_ID_BCM5464			0x002060b0
 #define PHY_ID_BCM5461			0x002060c0
 #define PHY_ID_BCM54612E		0x03625e60
@@ -65,6 +66,33 @@
 #define PHY_BRCM_CLEAR_RGMII_MODE	0x00004000
 #define PHY_BRCM_DIS_TXCRXC_NOENRGY	0x00008000
 
+/* Broadcom B502X0X_542XXXXCT RDB register definations */
+#define BCM_542XX_RDB_ADDR		0x1e	/* RDB indirect address reg */
+#define BCM_542XX_RDB_DATA		0x1f	/* RDB indirect data reg */
+#define BCM_542XX_RDB_ADDR_MASK		0x0fff	/* RDB indirect address mask */
+#define BCM_542XX_RDB_PHY_ECR		0x0	/* extended control reg */
+#define BCM_542XX_RDB_PHY_ISR		0x00a	/* interrupt status reg */
+#define BCM_542XX_RDB_PHY_IMR		0x00b	/* interrupt mask reg */
+#define BCM_542XX_RDB_CLK_ALIGN_CTRL	0x013
+#define BCM_542XX_RDB_MODE_CTRL		0x021
+#define BCM_542XX_RDB_COPPER_MISC_CTRL	0x02f
+#define BCM_542XX_RDB_SGMII_SLAVE	0x235
+#define BCM_542XX_RDB_AUTODET_MEDIUM	0x23e
+#define BCM_542XX_RDB_TOP_LEVEL_CONFIG	0x810
+
+#define BCM_542XX_RGMII_EN		BIT(7)
+#define BCM_542XX_RXC_INT_DELAY		BIT(8)
+#define BCM_542XX_GTXCLK_INT_DELAY	BIT(9)
+#define BCM_542XX_TOP_LEVEL_CONFIG	0x00b0
+#define BCM_542XX_RGMII_3P3V		BCM_542XX_TOP_LEVEL_CONFIG
+#define BCM_542XX_MODE_SEL		0x6
+#define BCM_542XX_1000BASEX		BIT(1)
+#define BCM_542XX_REG_1000X_EN		BIT(0)
+#define BCM_542XX_RGMII_AUTO_DET_MED_EN	BIT(0)
+#define BCM_542XX_POWER_DOWN		BIT(11)
+#define BCM_542XX_FIBER_LED		BIT(6)
+#define BCM_542XX_SGMII_SLAVE_MODE_EN	BIT(1)
+
 /* Broadcom BCM7xxx specific workarounds */
 #define PHY_BRCM_7XXX_REV(x)		(((x) >> 8) & 0xff)
 #define PHY_BRCM_7XXX_PATCH(x)		((x) & 0xff)
diff -uprN 4.14.79/include/linux/iommu.h 4.14.79_popcorn/include/linux/iommu.h
--- 4.14.79/include/linux/iommu.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/iommu.h	2020-05-24 22:41:30.678905719 -0400
@@ -41,6 +41,9 @@
  * if the IOMMU page table format is equivalent.
  */
 #define IOMMU_PRIV	(1 << 5)
+#define IOMMU_PROT_FLAGS (IOMMU_READ | IOMMU_WRITE | \
+			  IOMMU_CACHE | IOMMU_NOEXEC | IOMMU_MMIO)
+
 
 struct iommu_ops;
 struct iommu_group;
diff -uprN 4.14.79/include/linux/mm.h 4.14.79_popcorn/include/linux/mm.h
--- 4.14.79/include/linux/mm.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/mm.h	2020-05-24 22:41:30.706905631 -0400
@@ -218,6 +218,10 @@ extern unsigned int kobjsize(const void
 #define VM_HIGH_ARCH_4	BIT(VM_HIGH_ARCH_BIT_4)
 #endif /* CONFIG_ARCH_USES_HIGH_VMA_FLAGS */
 
+#ifdef CONFIG_POPCORN
+#define VM_FETCH_LOCAL	0x00800000
+#endif
+
 #if defined(CONFIG_X86)
 # define VM_PAT		VM_ARCH_1	/* PAT reserves whole VMA at once (x86) */
 #if defined (CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS)
@@ -1186,6 +1190,11 @@ static inline void clear_page_pfmemalloc
 
 #define VM_FAULT_HWPOISON_LARGE_MASK 0xf000 /* encodes hpage index for large hwpoison */
 
+#ifdef CONFIG_POPCORN
+#define VM_FAULT_CONTINUE	0x1000
+#define VM_FAULT_KILLED		0x2000
+#endif
+
 #define VM_FAULT_ERROR	(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | \
 			 VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE | \
 			 VM_FAULT_FALLBACK)
diff -uprN 4.14.79/include/linux/mm_types.h 4.14.79_popcorn/include/linux/mm_types.h
--- 4.14.79/include/linux/mm_types.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/mm_types.h	2020-05-24 22:41:30.706905631 -0400
@@ -17,6 +17,10 @@
 
 #include <asm/mmu.h>
 
+#ifdef CONFIG_POPCORN
+struct remote_context;
+#endif
+
 #ifndef AT_VECTOR_SIZE_ARCH
 #define AT_VECTOR_SIZE_ARCH 0
 #endif
@@ -501,10 +505,15 @@ struct mm_struct {
 #endif
 	struct work_struct async_put_work;
 
+#ifdef CONFIG_POPCORN
+       struct remote_context *remote;
+#endif
+
 #if IS_ENABLED(CONFIG_HMM)
 	/* HMM needs to track a few things per mm */
 	struct hmm *hmm;
 #endif
+
 } __randomize_layout;
 
 extern struct mm_struct init_mm;
diff -uprN 4.14.79/include/linux/nvme-lpm-ssr.h 4.14.79_popcorn/include/linux/nvme-lpm-ssr.h
--- 4.14.79/include/linux/nvme-lpm-ssr.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/linux/nvme-lpm-ssr.h	2020-05-24 22:41:30.714905607 -0400
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright(c) 2018 Broadcom
+ */
+
+#ifndef __NVME_LPM_SSR_H__
+#define __NVME_LPM_SSR_H__
+
+#include <stddef.h>
+
+enum ssr_states {
+	SSR_STATE_INVALID,
+	SSR_STATE_INIT,
+	SSR_STATE_DISARM,
+	SSR_STATE_ARM,
+	SSR_STATE_POWERLOSS,
+	SSR_STATE_INPROGRESS,
+	SSR_STATE_COMPLETE,
+	SSR_STATE_ERROR,
+};
+
+struct armed_ssr {
+	uint32_t sequence;
+	uint64_t memory_address;
+	uint64_t disk_address;
+	uint64_t length;
+} __attribute__((packed));
+
+struct disarmed_ssr {
+	uint32_t sequence;
+} __attribute__((packed));
+
+struct state_save_checkpoint {
+	uint32_t voltage;
+	uint64_t timestamp;
+} __attribute__((packed));
+
+struct ssr {
+	uint8_t state;
+	uint32_t sequence;
+	uint64_t nvme_error_code;
+	uint64_t ddr0_ecc_code;
+	uint64_t ddr1_ecc_code;
+	struct state_save_checkpoint power_loss;
+	struct state_save_checkpoint in_progress;
+	struct state_save_checkpoint complete;
+} __attribute__((packed));
+#define SSR_SIZE sizeof(struct ssr)
+
+enum {
+	NVME_LPM_CMD_GET_SSR = 0x53535201, /* cmd format in ASCII SSR<x>*/
+	NVME_LPM_CMD_ERASE_SSR,
+	NVME_LPM_CMD_ARM_SSR,
+	NVME_LPM_CMD_DISARM_SSR,
+	NVME_LPM_CMD_TRIGGER_SSR,
+};
+
+#define NVM_SSR_OFFSET	0x0
+#define OS_CRMU_SSRCMD_MEM 0x8f100100
+
+struct ssr_wrapper {
+	/*
+	 * MAIA must populate this signature indicating validity of cmd
+	 */
+#define MAIA_CRMU_VALID_REQUEST		0xbabebabe
+	uint32_t maia_crmu_valid_request;
+	/*
+	 * CRMU must populate this signature indicating status of command.
+	 * if done succussfully populate with CRMU_MAIA_VALID_RESPONSE or
+	 * 0x0 as erroneous condition.
+	 */
+#define MAX_CRMU_RESPONSE_TIMEOUT 1000 /* 100 msec */
+#define CRMU_MAIA_VALID_RESPONSE	0xfaceface
+	uint32_t crmu_maia_valid_response;
+	/*
+	 * MAIA uses this to send the command to MCU. MCU should clear this
+	 * indicating that command has been processed.
+	 */
+	uint32_t ssr_cmd_id;
+
+	/*
+	 * SSR struture. It should be populated with relevant field in case
+	 * other side expects anything i.e  sequence number
+	 */
+	struct ssr ssr;
+} __attribute__((packed));
+
+#define NVME_LPM_IOCTL_MAGIC		'N'
+#define NVME_LPM_IOCTL_GET_SSR		_IOR(NVME_LPM_IOCTL_MAGIC, 1, \
+						struct ssr)
+#define NVME_LPM_IOCTL_ERASE_SSR	_IO(NVME_LPM_IOCTL_MAGIC, 2)
+#define NVME_LPM_IOCTL_ARM_SSR		_IOW(NVME_LPM_IOCTL_MAGIC, 3, \
+						struct armed_ssr)
+#define NVME_LPM_IOCTL_DISARM_SSR	_IOW(NVME_LPM_IOCTL_MAGIC, 4, \
+						struct disarmed_ssr)
+#define NVME_LPM_IOCTL_TRIGGER_SSR	_IO(NVME_LPM_IOCTL_MAGIC, 5)
+#define NVME_LPM_IOCTL_READ		_IOW(NVME_LPM_IOCTL_MAGIC, 6, \
+						struct armed_ssr)
+#define NVME_LPM_IOCTL_AP_POLL		_IO(NVME_LPM_IOCTL_MAGIC, 7)
+
+struct nvme_lpm_drv_ops {
+	void *ctxt;
+	int (*nvme_destroy_backup_io_queues)(void *ctxt);
+	int (*nvme_build_backup_io_queues)(void *ctxt, uint64_t memory_address,
+					   uint64_t disk_address,
+					   uint64_t length,
+					   bool write_to_nvme,
+					   void *shared_nvme_data);
+	int (*nvme_initiate_xfers)(void *ctxt);
+	int (*nvme_poll_xfers)(void *ctxt);
+	int (*nvme_send_flush_cmd)(void *ctxt);
+};
+
+int register_nvme_lpm_ops(void *nvme_drv_ops);
+
+#endif
diff -uprN 4.14.79/include/linux/of_iommu.h 4.14.79_popcorn/include/linux/of_iommu.h
--- 4.14.79/include/linux/of_iommu.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/of_iommu.h	2020-05-24 22:41:30.718905594 -0400
@@ -6,20 +6,27 @@
 #include <linux/iommu.h>
 #include <linux/of.h>
 
+struct of_iommu_resv_region {
+	u32 busno;
+	u32 prot;
+	u64 bus_addr;
+	u64 size;
+};
+
 #ifdef CONFIG_OF_IOMMU
 
-extern int of_get_dma_window(struct device_node *dn, const char *prefix,
-			     int index, unsigned long *busno, dma_addr_t *addr,
-			     size_t *size);
+int of_get_resv_region(struct device_node *dn, const char *region, int *index,
+		      struct of_iommu_resv_region *of_region);
 
 extern const struct iommu_ops *of_iommu_configure(struct device *dev,
 					struct device_node *master_np);
 
+void of_iommu_resv_dma_regions(struct device_node *np, struct list_head *list);
+
 #else
 
-static inline int of_get_dma_window(struct device_node *dn, const char *prefix,
-			    int index, unsigned long *busno, dma_addr_t *addr,
-			    size_t *size)
+static inline int of_get_resv_region(struct device_node *dn, const char *region,
+			int *index, struct of_iommu_resv_region *of_region)
 {
 	return -EINVAL;
 }
@@ -30,6 +37,12 @@ static inline const struct iommu_ops *of
 	return NULL;
 }
 
+static inline int of_iommu_resv_dma_regions(struct device_node *np,
+					    struct list_head *list)
+{
+	return -EINVAL;
+}
+
 #endif	/* CONFIG_OF_IOMMU */
 
 extern struct of_device_id __iommu_of_table;
diff -uprN 4.14.79/include/linux/of_pci.h 4.14.79_popcorn/include/linux/of_pci.h
--- 4.14.79/include/linux/of_pci.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/of_pci.h	2020-05-24 22:41:30.718905594 -0400
@@ -21,7 +21,8 @@ int of_pci_get_max_link_speed(struct dev
 void of_pci_check_probe_only(void);
 int of_pci_map_rid(struct device_node *np, u32 rid,
 		   const char *map_name, const char *map_mask_name,
-		   struct device_node **target, u32 *id_out);
+		   const char *drop_mask_name, struct device_node **target,
+		   u32 *id_out);
 #else
 static inline int of_irq_parse_pci(const struct pci_dev *pdev, struct of_phandle_args *out_irq)
 {
@@ -59,7 +60,8 @@ of_get_pci_domain_nr(struct device_node
 
 static inline int of_pci_map_rid(struct device_node *np, u32 rid,
 			const char *map_name, const char *map_mask_name,
-			struct device_node **target, u32 *id_out)
+			const char *drop_mask_name, struct device_node **target,
+			u32 *id_out)
 {
 	return -EINVAL;
 }
diff -uprN 4.14.79/include/linux/pci-ecam.h 4.14.79_popcorn/include/linux/pci-ecam.h
--- 4.14.79/include/linux/pci-ecam.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/pci-ecam.h	2020-05-24 22:41:30.718905594 -0400
@@ -67,6 +67,7 @@ extern struct pci_ecam_ops thunder_pem_e
 extern struct pci_ecam_ops pci_thunder_ecam_ops; /* Cavium ThunderX 1.x */
 extern struct pci_ecam_ops xgene_v1_pcie_ecam_ops; /* APM X-Gene PCIe v1 */
 extern struct pci_ecam_ops xgene_v2_pcie_ecam_ops; /* APM X-Gene PCIe v2.x */
+extern struct pci_ecam_ops iproc_pcie_paxcv2_ecam_ops; /* iProc PAXCv2 */
 #endif
 
 #ifdef CONFIG_PCI_HOST_COMMON
diff -uprN 4.14.79/include/linux/pci.h 4.14.79_popcorn/include/linux/pci.h
--- 4.14.79/include/linux/pci.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/pci.h	2020-05-24 22:41:30.718905594 -0400
@@ -296,6 +296,7 @@ struct pci_dev {
 	void		*sysdata;	/* hook for sys-specific extension */
 	struct proc_dir_entry *procent;	/* device entry in /proc/bus/pci */
 	struct pci_slot	*slot;		/* Physical slot this device is in */
+	struct mutex bridge_lock;
 
 	unsigned int	devfn;		/* encoded device & function index */
 	unsigned short	vendor;
@@ -307,6 +308,7 @@ struct pci_dev {
 	u8		hdr_type;	/* PCI header type (`multi' flag masked out) */
 #ifdef CONFIG_PCIEAER
 	u16		aer_cap;	/* AER capability offset */
+	struct aer_stats *aer_stats;	/* AER stats for this device */
 #endif
 	u8		pcie_cap;	/* PCIe capability offset */
 	u8		msi_cap;	/* MSI capability offset */
@@ -371,6 +373,7 @@ struct pci_dev {
 
 	bool match_driver;		/* Skip attaching driver */
 	/* These fields are used by common fixups */
+	spinlock_t	lock;		/* Protect is_added and is_busmaster */
 	unsigned int	transparent:1;	/* Subtractive decode PCI bridge */
 	unsigned int	multifunction:1;/* Part of multi-function device */
 	/* keep track of device state */
@@ -1469,13 +1472,9 @@ static inline bool pcie_aspm_support_ena
 #endif
 
 #ifdef CONFIG_PCIEAER
-void pci_no_aer(void);
 bool pci_aer_available(void);
-int pci_aer_init(struct pci_dev *dev);
 #else
-static inline void pci_no_aer(void) { }
 static inline bool pci_aer_available(void) { return false; }
-static inline int pci_aer_init(struct pci_dev *d) { return -ENODEV; }
 #endif
 
 #ifdef CONFIG_PCIE_ECRC
diff -uprN 4.14.79/include/linux/pci_ids.h 4.14.79_popcorn/include/linux/pci_ids.h
--- 4.14.79/include/linux/pci_ids.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/pci_ids.h	2020-05-24 22:41:30.718905594 -0400
@@ -2371,6 +2371,9 @@
 #define PCI_VENDOR_ID_BELKIN		0x1799
 #define PCI_DEVICE_ID_BELKIN_F5D7010V7	0x701f
 
+#define PCI_VENDOR_ID_CADENCE		0x17cd
+#define PCI_DEVICE_ID_CADENCE_AVIP	0x0100
+
 #define PCI_VENDOR_ID_RDC		0x17f3
 #define PCI_DEVICE_ID_RDC_R6020		0x6020
 #define PCI_DEVICE_ID_RDC_R6030		0x6030
diff -uprN 4.14.79/include/linux/sched.h 4.14.79_popcorn/include/linux/sched.h
--- 4.14.79/include/linux/sched.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/sched.h	2020-05-24 22:41:30.746905507 -0400
@@ -27,7 +27,7 @@
 #include <linux/signal_types.h>
 #include <linux/mm_types_task.h>
 #include <linux/task_io_accounting.h>
-
+#include <linux/completion.h>
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
 struct backing_dev_info;
@@ -1123,6 +1123,39 @@ struct task_struct {
 #ifdef CONFIG_MMU
 	struct task_struct		*oom_reaper_list;
 #endif
+#ifdef CONFIG_POPCORN
+       struct remote_context *remote;
+       union {
+               int peer_nid;
+               int remote_nid;
+               int origin_nid;
+       };
+       union {
+               pid_t peer_pid;
+               pid_t remote_pid;
+               pid_t origin_pid;
+       };
+
+       bool is_worker;                 /* kernel thread that manages the process*/
+       bool at_remote;                 /* Is executing on behalf of another node? */
+       volatile void *remote_work;
+       struct completion remote_work_pended;
+       int migration_target_nid;
+       int backoff_weight;
+
+#ifdef CONFIG_POPCORN_STAT_PGFAULTS
+       unsigned long fault_address;
+       int fault_retry;
+       ktime_t fault_start;
+#endif
+
+       /*
+        * scheduling -- antoniob
+        * in jiffies for load accounting
+        */
+       unsigned long lutime, lstime, llasttimestamp;
+#endif
+
 #ifdef CONFIG_VMAP_STACK
 	struct vm_struct		*stack_vm_area;
 #endif
diff -uprN 4.14.79/include/linux/syscalls.h 4.14.79_popcorn/include/linux/syscalls.h
--- 4.14.79/include/linux/syscalls.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/linux/syscalls.h	2020-05-24 22:41:30.758905470 -0400
@@ -941,4 +941,11 @@ asmlinkage long sys_pkey_free(int pkey);
 asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags,
 			  unsigned mask, struct statx __user *buffer);
 
+struct popcorn_thread_status;
+struct popcorn_node_info;
+asmlinkage long sys_popcorn_migrate(int nid, void __user *uregs);
+asmlinkage long sys_popcorn_propose_migration(pid_t pid, int nid);
+asmlinkage long sys_popcorn_get_thread_status(struct popcorn_thread_status __user *status);
+asmlinkage long sys_popcorn_get_node_info(int * __user _my_nid, struct popcorn_node_info __user *info);
+
 #endif
diff -uprN 4.14.79/include/popcorn/bundle.h 4.14.79_popcorn/include/popcorn/bundle.h
--- 4.14.79/include/popcorn/bundle.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/bundle.h	2020-05-24 22:41:30.794905358 -0400
@@ -0,0 +1,42 @@
+#ifndef __POPCORN_RACK_H__
+#define __POPCORN_RACK_H__
+
+#define MAX_POPCORN_NODES 32
+#if (MAX_POPCORN_NODES > 62)
+#error Currently support up to 62 nodes
+#endif
+
+enum popcorn_arch {
+	POPCORN_ARCH_UNKNOWN = -1,
+	POPCORN_ARCH_ARM = 0,
+	POPCORN_ARCH_X86 = 1,
+	POPCORN_ARCH_PPC = 2,
+	POPCORN_ARCH_MAX,
+};
+
+extern int my_nid;
+extern const enum popcorn_arch my_arch;
+
+bool get_popcorn_node_online(int nid);
+void set_popcorn_node_online(int nid, bool online);
+
+int get_popcorn_node_arch(int nid);
+
+void broadcast_my_node_info(int nr_nodes);
+
+int popcorn_nodes_init(void);
+
+struct popcorn_thread_status {
+	int current_nid;
+	int proposed_nid;
+	int peer_nid;
+	pid_t peer_pid;
+};
+
+struct popcorn_node_info {
+	unsigned int status;
+	int arch;
+	int distance;
+};
+
+#endif
diff -uprN 4.14.79/include/popcorn/cpuinfo.h 4.14.79_popcorn/include/popcorn/cpuinfo.h
--- 4.14.79/include/popcorn/cpuinfo.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/cpuinfo.h	2020-05-24 22:41:30.794905358 -0400
@@ -0,0 +1,96 @@
+/*
+ * File:
+ *  cpuinfo.c
+ *
+ * Description:
+ * 	Provides the architecture specific functionality of populating cpuinfo
+ *
+ * Created on:
+ * 	Oct 10, 2014
+ *
+ * Author:
+ *  Akshay Giridhar, SSRG, Virginia Tech
+ *  Antonio Barbalace, SSRG, Virginia Tech
+ *  Sharath Kumar Bhat, SSRG, Virginia Tech
+ *  Sang-Hoon Kim, SSRG, Virginia Tech
+ */
+
+#ifndef _LINUX_POPCORN_CPUINFO_H
+#define _LINUX_POPCORN_CPUINFO_H
+
+#define MAX_ARM_CORES 128
+#define MAX_X86_CORES 32
+
+#include <popcorn/bundle.h>
+
+/* For x86_64 cores */
+struct percore_info_x86 {
+	unsigned int processor;
+	char vendor_id[16];
+	int cpu_family;
+	unsigned int model;
+	char model_name[64];
+	int stepping;
+	unsigned long microcode;
+	unsigned cpu_freq;
+	int cache_size;
+	char fpu[3];
+	char fpu_exception[3];
+	int cpuid_level;
+	char wp[3];
+	char flags[640];
+	unsigned long nbogomips;
+	int TLB_size;
+	unsigned int clflush_size;
+	int cache_alignment;
+	unsigned int bits_physical;
+	unsigned int bits_virtual;
+	char power_management[64];
+};
+
+struct cpuinfo_arch_x86 {
+	unsigned int num_cpus;
+	struct percore_info_x86 cores[MAX_X86_CORES];
+};
+
+
+/* For arm64 cores */
+struct percore_info_arm64 {
+	unsigned int processor_id;
+	bool compat;
+	char model_name[64];
+	int model_rev;
+	char model_elf[8];
+	unsigned long bogo_mips;
+	unsigned long bogo_mips_fraction;
+	char flags[64];
+	unsigned int cpu_implementer;
+	unsigned int cpu_archtecture;
+	unsigned int cpu_variant;
+	unsigned int cpu_part;
+	unsigned int cpu_revision;
+};
+
+struct cpuinfo_arch_arm64 {
+	unsigned int num_cpus;
+	struct percore_info_arm64 cores[MAX_ARM_CORES];
+};
+
+
+struct remote_cpu_info {
+	enum popcorn_arch arch_type;
+	union {
+		struct cpuinfo_arch_x86 x86;
+		struct cpuinfo_arch_arm64 arm64;
+	};
+};
+
+
+struct seq_file;
+
+extern int fill_cpu_info(struct remote_cpu_info *res);
+extern void send_remote_cpu_info_request(unsigned int nid);
+extern unsigned int get_number_cpus_from_remote_node(unsigned int nid);
+extern int remote_proc_cpu_info(struct seq_file *m, unsigned int nid, unsigned int vpos);
+
+#endif
diff -uprN 4.14.79/include/popcorn/debug.h 4.14.79_popcorn/include/popcorn/debug.h
--- 4.14.79/include/popcorn/debug.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/debug.h	2020-05-24 22:41:30.794905358 -0400
@@ -0,0 +1,50 @@
+#ifndef __INCLUDE_POPCORN_DEBUG_H__
+#define __INCLUDE_POPCORN_DEBUG_H__
+
+#define PCNPRINTK(...) printk(KERN_INFO "popcorn: " __VA_ARGS__)
+#define PCNPRINTK_ERR(...) printk(KERN_ERR "popcorn: " __VA_ARGS__)
+
+/*
+ * Function macros
+ */
+#ifdef CONFIG_POPCORN_DEBUG
+#define PRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define PRINTK(...)
+#endif
+
+
+#ifdef CONFIG_POPCORN_DEBUG_PROCESS_SERVER
+#define PSPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define PSPRINTK(...)
+#endif
+
+
+#ifdef CONFIG_POPCORN_DEBUG_VMA_SERVER
+#define VSPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define VSPRINTK(...)
+#endif
+
+
+#ifdef CONFIG_POPCORN_DEBUG_PAGE_SERVER
+#define PGPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define PGPRINTK(...)
+#endif
+
+
+#ifdef CONFIG_POPCORN_DEBUG_MSG_LAYER
+#define MSGPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define MSGPRINTK(...)
+#endif
+
+#ifdef CONFIG_POPCORN_DEBUG_SYSCALL_SERVER
+#define SSPRINTK(...) printk(KERN_INFO __VA_ARGS__)
+#else
+#define SSPRINTK(...)
+#endif
+
+#endif /*  __INCLUDE_POPCORN_DEBUG_H__ */
diff -uprN 4.14.79/include/popcorn/page_server.h 4.14.79_popcorn/include/popcorn/page_server.h
--- 4.14.79/include/popcorn/page_server.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/page_server.h	2020-05-24 22:41:30.794905358 -0400
@@ -0,0 +1,44 @@
+/**
+ * @file page_server.h
+ * (public interface)
+ *
+ * Popcorn Linux page server public interface
+ * This work is an extension of Marina Sadini MS Thesis, plese refer to the
+ * Thesis for further information about the algorithm.
+ *
+ * @author Sang-Hoon Kim, SSRG Virginia Tech 2017
+ * @author Antonio Barbalace, SSRG Virginia Tech 2016
+ */
+
+#ifndef INCLUDE_POPCORN_PAGE_SERVER_H_
+#define INCLUDE_POPCORN_PAGE_SERVER_H_
+
+struct fault_handle;
+
+/*
+ * Entry points for dealing with page fault in Popcorn Rack
+ */
+int page_server_handle_pte_fault(
+		struct mm_struct *mm, struct vm_area_struct *vma,
+		unsigned long address, pmd_t *pmd, pte_t *pte, pte_t entry,
+		unsigned int flags);
+
+/*
+ * Flush pages in remote to the origin
+ */
+int page_server_flush_remote_pages(void);
+
+void page_server_zap_pte(
+	struct vm_area_struct *vma, unsigned long addr, pte_t *pte, pte_t *pteval);
+
+int page_server_get_userpage(u32 __user *uaddr, struct fault_handle **handle, char *mode);
+void page_server_put_userpage(struct fault_handle *fh, char *mode);
+
+void page_server_start_mm_fault(unsigned long address);
+int page_server_end_mm_fault(int ret);
+
+void page_server_panic(bool condition, struct mm_struct *mm, unsigned long address, pte_t *pte, pte_t pte_val);
+
+int page_server_release_page_ownership(struct vm_area_struct *vma, unsigned long addr);
+
+#endif /* INCLUDE_POPCORN_PAGE_SERVER_H_ */
diff -uprN 4.14.79/include/popcorn/pcn_kmsg.h 4.14.79_popcorn/include/popcorn/pcn_kmsg.h
--- 4.14.79/include/popcorn/pcn_kmsg.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/pcn_kmsg.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,217 @@
+/**
+ * Header file for Popcorn inter-kernel messaging layer
+ *
+ * (C) Ben Shelton   <beshelto@vt.edu> 2013
+ *     Sang-Hoon Kim <sanghoon@vt.edu> 2017-2018
+ */
+
+#ifndef __POPCORN_PCN_KMSG_H__
+#define __POPCORN_PCN_KMSG_H__
+
+#include <linux/types.h>
+#include <linux/seq_file.h>
+
+/* Enumerate message types */
+enum pcn_kmsg_type {
+	/* Thread migration */
+	PCN_KMSG_TYPE_NODE_INFO,
+	PCN_KMSG_TYPE_STAT_START,
+	PCN_KMSG_TYPE_TASK_MIGRATE,
+	PCN_KMSG_TYPE_TASK_MIGRATE_BACK,
+	PCN_KMSG_TYPE_TASK_PAIRING,
+	PCN_KMSG_TYPE_TASK_EXIT_ORIGIN,
+	PCN_KMSG_TYPE_TASK_EXIT_REMOTE,
+
+	/* VMA synchronization */
+	PCN_KMSG_TYPE_VMA_INFO_REQUEST,
+	PCN_KMSG_TYPE_VMA_INFO_RESPONSE,
+	PCN_KMSG_TYPE_VMA_OP_REQUEST,
+	PCN_KMSG_TYPE_VMA_OP_RESPONSE,
+
+	/* Page consistency protocol */
+	PCN_KMSG_TYPE_REMOTE_PAGE_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_PAGE_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_PAGE_RESPONSE_SHORT,
+	PCN_KMSG_TYPE_PAGE_INVALIDATE_REQUEST,
+	PCN_KMSG_TYPE_PAGE_INVALIDATE_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_PAGE_FLUSH,	/* XXX page flush is not working now */
+	PCN_KMSG_TYPE_REMOTE_PAGE_RELEASE,
+	PCN_KMSG_TYPE_REMOTE_PAGE_FLUSH_ACK,
+
+	/* Distributed futex */
+	PCN_KMSG_TYPE_FUTEX_REQUEST,
+	PCN_KMSG_TYPE_FUTEX_RESPONSE,
+	PCN_KMSG_TYPE_STAT_END,
+
+	/* Performance experiments */
+	PCN_KMSG_TYPE_TEST_REQUEST,
+	PCN_KMSG_TYPE_TEST_RESPONSE,
+	PCN_KMSG_TYPE_TEST_RDMA_REQUEST,
+	PCN_KMSG_TYPE_TEST_RDMA_RESPONSE,
+
+	/* Provide the single system image */
+	PCN_KMSG_TYPE_REMOTE_PROC_CPUINFO_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_PROC_CPUINFO_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_PROC_MEMINFO_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_PROC_MEMINFO_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_PROC_PS_REQUEST,
+	PCN_KMSG_TYPE_REMOTE_PROC_PS_RESPONSE,
+
+	/* Schedule server */
+	PCN_KMSG_TYPE_SCHED_PERIODIC,		/* XXX sched requires help!! */
+
+	/* Popcorn socket redirection */
+	PCN_KMSG_TYPE_REMOTE_SOCKET,
+	PCN_KMSG_TYPE_REMOTE_SETSOCKOPT,
+	PCN_KMSG_TYPE_REMOTE_SOCKET_RESPONSE,
+	PCN_KMSG_TYPE_REMOTE_BIND,
+	PCN_KMSG_TYPE_REMOTE_LISTEN,
+	PCN_KMSG_TYPE_REMOTE_ACCEPT4,
+
+	PCN_KMSG_TYPE_SYSCALL_FWD,
+	PCN_KMSG_TYPE_SYSCALL_REP,
+	PCN_KMSG_TYPE_MAX
+};
+
+/* Enumerate message priority. XXX Priority is not supported yet. */
+enum pcn_kmsg_prio {
+	PCN_KMSG_PRIO_LOW,
+	PCN_KMSG_PRIO_NORMAL,
+	PCN_KMSG_PRIO_HIGH,
+};
+
+/* Message header */
+struct pcn_kmsg_hdr {
+	int from_nid			:6;
+	enum pcn_kmsg_prio prio	:2;
+	enum pcn_kmsg_type type	:8;
+	size_t size;
+} __attribute__((packed));
+
+#define PCN_KMSG_FROM_NID(x) \
+	(((struct pcn_kmsg_message *)x)->header.from_nid)
+#define PCN_KMSG_SIZE(x) (sizeof(struct pcn_kmsg_hdr) + x)
+
+#define PCN_KMSG_MAX_SIZE (64UL << 10)
+#define PCN_KMSG_MAX_PAYLOAD_SIZE \
+	(PCN_KMSG_MAX_SIZE - sizeof(struct pcn_kmsg_hdr))
+
+
+#define DEFINE_PCN_KMSG(type, fields) \
+	typedef struct {				\
+		struct pcn_kmsg_hdr header;	\
+		fields;				\
+	} __attribute__((packed)) type
+
+struct pcn_kmsg_message {
+	struct pcn_kmsg_hdr header;
+	unsigned char payload[PCN_KMSG_MAX_PAYLOAD_SIZE];
+} __attribute__((packed));
+
+void pcn_kmsg_dump(struct pcn_kmsg_message *msg);
+
+
+/* SETUP */
+
+/* Function pointer to callback functions */
+typedef int (*pcn_kmsg_cbftn)(struct pcn_kmsg_message *);
+
+/* Register a callback function to handle the message type */
+int pcn_kmsg_register_callback(enum pcn_kmsg_type type, pcn_kmsg_cbftn callback);
+
+/* Unregister a callback function for the message type */
+int pcn_kmsg_unregister_callback(enum pcn_kmsg_type type);
+
+
+/* MESSAGING */
+
+/**
+ * Send @msg whose size is @msg_size to the node @dest_nid.
+ * @msg is sent synchronously; it is safe to deallocate @msg after the return.
+ */
+int pcn_kmsg_send(enum pcn_kmsg_type type, int dest_nid, void *msg, size_t msg_size);
+
+/**
+ * Post @msg whose size is @msg_size to be sent to the node @dest_nid.
+ * The message should be allocated through pcn_kmsg_get(), and the message
+ * is reclaimed automatically once it is sent.
+ */
+int pcn_kmsg_post(enum pcn_kmsg_type type, int dest_nid, void *msg, size_t msg_size);
+
+/**
+ * Get message buffer for posting. Note pcn_kmsg_put() is for returning
+ * unused buffer without posting it; posted message is reclaimed automatically.
+ */
+void *pcn_kmsg_get(size_t size);
+void pcn_kmsg_put(void *msg);
+
+/**
+ * Process the received messag @msg. Each message layer should start processing
+ * the request by calling this function
+ */
+void pcn_kmsg_process(struct pcn_kmsg_message *msg);
+
+/**
+ * Return received message @msg after handling to recyle it. @msg becomes
+ * unavailable after the call. Make sure return received messages otherwise
+ * the message layer will panick.
+ */
+void pcn_kmsg_done(void *msg);
+
+/**
+ * Print out transport-specific statistics into @buffer
+ */
+void pcn_kmsg_stat(struct seq_file *seq, void *v);
+
+
+struct pcn_kmsg_rdma_handle {
+	u32 rkey;
+	void *addr;
+	dma_addr_t dma_addr;
+	void *private;
+};
+
+/**
+ * Pin @buffer for RDMA and get @rdma_addr and @rdma_key.
+ */
+struct pcn_kmsg_rdma_handle *pcn_kmsg_pin_rdma_buffer(void *buffer, size_t size);
+
+void pcn_kmsg_unpin_rdma_buffer(struct pcn_kmsg_rdma_handle *handle);
+
+int pcn_kmsg_rdma_write(int dest_nid, dma_addr_t rdma_addr, void *addr, size_t size, u32 rdma_key);
+
+int pcn_kmsg_rdma_read(int from_nid, void *addr, dma_addr_t rdma_addr, size_t size, u32 rdma_key);
+
+/* TRANSPORT DESCRIPTOR */
+enum {
+	PCN_KMSG_FEATURE_RDMA = 1,
+};
+
+/**
+ * Check the features that the transport layer provides. Return true iff all
+ * features are supported.
+ */
+bool pcn_kmsg_has_features(unsigned int features);
+
+struct pcn_kmsg_transport {
+	char *name;
+	unsigned long features;
+
+	struct pcn_kmsg_message *(*get)(size_t);
+	void (*put)(struct pcn_kmsg_message *);
+
+	int (*send)(int, struct pcn_kmsg_message *, size_t);
+	int (*post)(int, struct pcn_kmsg_message *, size_t);
+	void (*done)(struct pcn_kmsg_message *);
+
+	void (*stat)(struct seq_file *, void *);
+
+	struct pcn_kmsg_rdma_handle *(*pin_rdma_buffer)(void *, size_t);
+	void (*unpin_rdma_buffer)(struct pcn_kmsg_rdma_handle *);
+	int (*rdma_write)(int, dma_addr_t, void *, size_t, u32);
+	int (*rdma_read)(int, void *, dma_addr_t, size_t, u32);
+};
+
+void pcn_kmsg_set_transport(struct pcn_kmsg_transport *tr);
+
+#endif /* __POPCORN_PCN_KMSG_H__ */
diff -uprN 4.14.79/include/popcorn/process_server.h 4.14.79_popcorn/include/popcorn/process_server.h
--- 4.14.79/include/popcorn/process_server.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/process_server.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,17 @@
+#ifndef __POPCORN_PROCESS_SERVER_H
+#define __POPCORN_PROCESS_SERVER_H
+
+struct task_struct;
+
+int process_server_do_migration(struct task_struct* tsk, unsigned int dst_nid, void __user *uregs);
+int process_server_task_exit(struct task_struct *tsk);
+int update_frame_pointer(void);
+
+long process_server_do_futex_at_remote(u32 __user *uaddr, int op, u32 val,
+		bool valid_ts, struct timespec *ts,
+		u32 __user *uaddr2, u32 val2, u32 val3);
+
+struct remote_context;
+void free_remote_context(struct remote_context *);
+
+#endif /* __POPCORN_PROCESS_SERVER_H */
diff -uprN 4.14.79/include/popcorn/regset.h 4.14.79_popcorn/include/popcorn/regset.h
--- 4.14.79/include/popcorn/regset.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/regset.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,98 @@
+/*
+ * File:
+ * process_server_macros.h
+ *
+ * Description:
+ * 	this file provides the architecture specific macro and structures of the
+ *  helper functionality implementation of the process server
+ *
+ * Created on:
+ * 	Sep 19, 2014
+ *
+ * Author:
+ * 	Sharath Kumar Bhat, SSRG, VirginiaTech
+ *
+ */
+
+#ifndef PROCESS_SERVER_ARCH_MACROS_H_
+#define PROCESS_SERVER_ARCH_MACROS_H_
+
+#include <popcorn/bundle.h>
+
+struct regset_x86_64 {
+	/* Program counter/instruction pointer */
+	uint64_t rip;
+
+	/* General purpose registers */
+	uint64_t rax, rdx, rcx, rbx,
+			 rsi, rdi, rbp, rsp,
+			 r8, r9, r10, r11,
+			 r12, r13, r14, r15;
+
+	/* Multimedia-extension (MMX) registers */
+	uint64_t mmx[8];
+
+	/* Streaming SIMD Extension (SSE) registers */
+	unsigned __int128 xmm[16];
+
+	/* x87 floating point registers */
+	long double st[8];
+
+	/* Segment registers */
+	uint32_t cs, ss, ds, es, fs, gs;
+
+	/* Flag register */
+	uint64_t rflags;
+};
+
+struct regset_aarch64 {
+	/* Stack pointer & program counter */
+	uint64_t sp;
+	uint64_t pc;
+
+	/* General purpose registers */
+	uint64_t x[31];
+
+	/* FPU/SIMD registers */
+	unsigned __int128 v[32];
+};
+
+struct regset_powerpc {
+	unsigned long nip;
+	unsigned long msr;
+	unsigned long ctr;
+	unsigned long link;
+	unsigned long xer;
+	unsigned long ccr;
+
+	unsigned long gpr[32];
+	uint64_t fpr[32];
+
+	unsigned long orig_gpr3;	/* Used for restarting system calls */
+	unsigned long softe;		/* Soft enabled/disabled */
+};
+
+struct field_arch {
+	unsigned long tls;
+	unsigned long oob[4];
+	bool fpu_active;
+
+	union {
+		unsigned long regsets;
+		struct regset_x86_64 regs_x86;
+		struct regset_aarch64 regs_aarch;
+		struct regset_powerpc regs_ppc;
+	};
+};
+
+static inline size_t regset_size(int arch) {
+	const size_t sizes[] = {
+		sizeof(struct regset_aarch64),
+		sizeof(struct regset_x86_64),
+		sizeof(struct regset_powerpc),
+	};
+	BUG_ON(arch <= POPCORN_ARCH_UNKNOWN || arch >= POPCORN_ARCH_MAX);
+	return sizes[arch];
+}
+
+#endif
diff -uprN 4.14.79/include/popcorn/remote_meminfo.h 4.14.79_popcorn/include/popcorn/remote_meminfo.h
--- 4.14.79/include/popcorn/remote_meminfo.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/remote_meminfo.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,62 @@
+#ifndef _LINUX_POPCORN_REMOTE_MEMINFO_H
+#define _LINUX_POPCORN_REMOTE_MEMINFO_H
+
+#include <popcorn/pcn_kmsg.h>
+
+#define REMOTE_MEMINFO_REQUEST_FIELDS \
+	int nid; \
+	int origin_ws;
+DEFINE_PCN_KMSG(remote_mem_info_request_t, REMOTE_MEMINFO_REQUEST_FIELDS);
+
+#define REMOTE_MEMINFO_RESPONSE_FIELDS \
+	int nid; \
+	int origin_ws; \
+	unsigned long MemTotal; \
+	unsigned long MemFree; \
+	unsigned long MemAvailable; \
+	unsigned long Buffers; \
+	unsigned long Cached; \
+	unsigned long SwapCached; \
+	unsigned long Active; \
+	unsigned long Inactive; \
+	unsigned long Active_anon; \
+	unsigned long Inactive_anon; \
+	unsigned long Active_file; \
+	unsigned long Inactive_file; \
+	unsigned long Unevictable; \
+	unsigned long Mlocked; \
+	unsigned long HighTotal; \
+	unsigned long HighFree; \
+	unsigned long LowTotal; \
+	unsigned long LowFree; \
+	unsigned long MmapCopy; \
+	unsigned long SwapTotal; \
+	unsigned long SwapFree; \
+	unsigned long Dirty; \
+	unsigned long Writeback; \
+	unsigned long AnonPages; \
+	unsigned long Mapped; \
+	unsigned long Shmem; \
+	unsigned long Slab; \
+	unsigned long SReclaimable; \
+	unsigned long SUnreclaim; \
+	unsigned long KernelStack; \
+	unsigned long PageTables; \
+	unsigned long Quicklists; \
+	unsigned long NFS_Unstable; \
+	unsigned long Bounce; \
+	unsigned long WritebackTmp; \
+	unsigned long CommitLimit; \
+	unsigned long Committed_AS; \
+	unsigned long VmallocTotal; \
+	unsigned long VmallocUsed; \
+	unsigned long VmallocChunk; \
+	unsigned long HardwareCorrupted; \
+	unsigned long AnonHugePages; \
+	unsigned long CmaTotal; \
+	unsigned long CmaFree;
+DEFINE_PCN_KMSG(remote_mem_info_response_t, REMOTE_MEMINFO_RESPONSE_FIELDS);
+
+int remote_proc_mem_info(remote_mem_info_response_t *total);
+
+#endif
diff -uprN 4.14.79/include/popcorn/stat.h 4.14.79_popcorn/include/popcorn/stat.h
--- 4.14.79/include/popcorn/stat.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/stat.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,22 @@
+/*
+ * stat.h
+ *
+ *  Created on: May 22, 2017
+ *      Author: Sang-Hoon Kim (sanghoon@vt.edu)
+ */
+
+#ifndef __KERNEL_POPCORN_STAT_H__
+#define __KERNEL_POPCORN_STAT_H__
+
+struct pcn_kmsg_message;
+
+void account_pcn_message_sent(struct pcn_kmsg_message *msg);
+void account_pcn_message_recv(struct pcn_kmsg_message *msg);
+
+void account_pcn_rdma_write(size_t size);
+void account_pcn_rdma_read(size_t size);
+
+#define POPCORN_STAT_FMT  "%12llu  %12llu  %s\n"
+#define POPCORN_STAT_FMT2 "%8llu.%03llu  %8llu.%03llu  %s\n"
+
+#endif /* KERNEL_POPCORN_STAT_H_ */
diff -uprN 4.14.79/include/popcorn/syscall_server.h 4.14.79_popcorn/include/popcorn/syscall_server.h
--- 4.14.79/include/popcorn/syscall_server.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/syscall_server.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,41 @@
+#ifndef __KERNEL_POPCORN_REMOTE_SOCKET_H__
+#define __KERNEL_POPCORN_REMOTE_SOCKET_H__
+
+
+int redirect_socket(int family, int type, int protocol);
+int redirect_setsockopt(int fd, int level, int optname, char __user * optval,
+			int optlen);
+int redirect_bind(int fd, struct sockaddr __user *umyaddr, int addrlen);
+int redirect_listen(int fd, int backlog);
+int redirect_accept4(int fd, struct sockaddr __user *upeer_sockaddr,
+		     int __user *upeer_addrlen, int flag);
+long redirect_shutdown(int, int);
+long redirect_recvfrom(int, void __user *, size_t, unsigned,
+				struct sockaddr __user *, int __user *);
+
+long redirect_epoll_create1(int flags);
+long redirect_epoll_ctl(int epfd, int op, int fd,
+				struct epoll_event __user *event);
+long redirect_epoll_wait(int epfd, struct epoll_event __user *events,
+				int maxevents, int timeout);
+long redirect_epoll_pwait(int epfd, struct epoll_event __user *events,
+				int maxevents, int timeout,
+				const sigset_t __user *sigmask,
+				size_t sigsetsize);
+long redirect_select(int n, fd_set __user *inp, fd_set __user *outp,
+			fd_set __user *exp, struct timeval __user *tvp);
+
+long redirect_read(unsigned int fd, char __user *buf, size_t count);
+long redirect_write(unsigned int fd, const char __user *buf, size_t count);
+long redirect_open(const char __user *filename, int flags, umode_t mode);
+long redirect_close(unsigned int fd);
+long redirect_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg);
+long redirect_writev(unsigned long fd,
+			   const struct iovec __user *vec,
+			   unsigned long vlen);
+long redirect_fstat(unsigned int fd,
+			struct stat __user *statbuf);
+long redirect_sendfile64(int out_fd, int in_fd,
+			       loff_t __user *offset, size_t count);
+long redirect_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);
+#endif
diff -uprN 4.14.79/include/popcorn/types.h 4.14.79_popcorn/include/popcorn/types.h
--- 4.14.79/include/popcorn/types.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/types.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,28 @@
+/**
+ * @file include/popcorn/types.h
+ *
+ * Define constant variables and define optional features
+ *
+ * @author Sang-Hoon Kim, SSRG Virginia Tech, 2017
+ * @author Marina Sadini, SSRG Virginia Tech, 2013
+ */
+
+#ifndef __INCLUDE_POPCORN_TYPES_H__
+#define __INCLUDE_POPCORN_TYPES_H__
+
+#include <linux/sched.h>
+
+static inline bool distributed_process(struct task_struct *tsk)
+{
+	if (!tsk->mm) return false;
+	return !!tsk->mm->remote;
+}
+
+static inline bool distributed_remote_process(struct task_struct *tsk)
+{
+	return distributed_process(tsk) && tsk->at_remote;
+}
+
+#include <popcorn/debug.h>
+
+#endif /* __INCLUDE_POPCORN_TYPES_H__ */
diff -uprN 4.14.79/include/popcorn/vma_server.h 4.14.79_popcorn/include/popcorn/vma_server.h
--- 4.14.79/include/popcorn/vma_server.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/popcorn/vma_server.h	2020-05-24 22:41:30.798905345 -0400
@@ -0,0 +1,41 @@
+/**
+ * @file vma_server.h
+ * (public interface)
+ *
+ * Popcorn Linux VMA server public interface
+ * This work is an extension of David Katz MS Thesis, please refer to the
+ * Thesis for further information about the algorithm.
+ *
+ * @author Antonio Barbalace, SSRG Virginia Tech 2016
+ * @author Sang-Hoon Kim, SSRG Virginia Tech 2017.
+ */
+
+#ifndef INCLUDE_POPCORN_VMA_SERVER_H_
+#define INCLUDE_POPCORN_VMA_SERVER_H_
+
+
+/**
+ * VMA operation handlers for origin
+ */
+int vma_server_munmap_origin(unsigned long start, size_t len, int nid_except);
+
+
+/**
+ * Retrieve VMAs from origin
+ */
+int vma_server_fetch_vma(struct task_struct *tsk, unsigned long address);
+
+/**
+ * VMA operation handler for remote
+ */
+unsigned long vma_server_mmap_remote(struct file *file,
+		unsigned long addr, unsigned long len,
+		unsigned long prot, unsigned long flags, unsigned long pgoff);
+int vma_server_munmap_remote(unsigned long start, size_t len);
+int vma_server_brk_remote(unsigned long oldbrk, unsigned long brk);
+int vma_server_madvise_remote(unsigned long start, size_t len, int behavior);
+int vma_server_mprotect_remote(unsigned long start, size_t len, unsigned long prot);
+int vma_server_mremap_remote(unsigned long addr, unsigned long old_len,
+		unsigned long new_len, unsigned long flags, unsigned long new_addr);
+
+#endif /* INCLUDE_POPCORN_VMA_SERVER_H_ */
diff -uprN 4.14.79/include/uapi/asm-generic/mman-common.h 4.14.79_popcorn/include/uapi/asm-generic/mman-common.h
--- 4.14.79/include/uapi/asm-generic/mman-common.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/uapi/asm-generic/mman-common.h	2020-05-24 22:41:30.818905283 -0400
@@ -62,6 +62,10 @@
 #define MADV_WIPEONFORK 18		/* Zero memory on fork, child only */
 #define MADV_KEEPONFORK 19		/* Undo MADV_WIPEONFORK */
 
+#ifdef CONFIG_POPCORN
+#define MADV_RELEASE 20
+#endif
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff -uprN 4.14.79/include/uapi/asm-generic/unistd.h 4.14.79_popcorn/include/uapi/asm-generic/unistd.h
--- 4.14.79/include/uapi/asm-generic/unistd.h	2018-11-04 08:52:51.000000000 -0500
+++ 4.14.79_popcorn/include/uapi/asm-generic/unistd.h	2020-05-24 22:41:30.818905283 -0400
@@ -732,9 +732,16 @@ __SYSCALL(__NR_pkey_alloc,    sys_pkey_a
 __SYSCALL(__NR_pkey_free,     sys_pkey_free)
 #define __NR_statx 291
 __SYSCALL(__NR_statx,     sys_statx)
-
+#define __NR_popcorn_migrate 292
+__SYSCALL(__NR_popcorn_migrate, sys_popcorn_migrate)
+#define __NR_popcorn_propose_migration 293
+__SYSCALL(__NR_popcorn_propose_migration, sys_popcorn_propose_migration)
+#define __NR_popcorn_get_thread_status 294
+__SYSCALL(__NR_popcorn_get_thread_status, sys_popcorn_get_thread_status)
+#define __NR_popcorn_get_node_info 295
+__SYSCALL(__NR_popcorn_get_node_info, sys_popcorn_get_node_info)
 #undef __NR_syscalls
-#define __NR_syscalls 292
+#define __NR_syscalls 296
 
 /*
  * All syscalls below here should go away really,
diff -uprN 4.14.79/include/uapi/linux/bcm_dte.h 4.14.79_popcorn/include/uapi/linux/bcm_dte.h
--- 4.14.79/include/uapi/linux/bcm_dte.h	1969-12-31 19:00:00.000000000 -0500
+++ 4.14.79_popcorn/include/uapi/linux/bcm_dte.h	2020-05-24 22:41:30.822905271 -0400
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License version 2 (GPLv2) for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 (GPLv2) along with this source code.
+ */
+
+#ifndef _BCM_IPROC_UAPI_DTE_H_
+#define _BCM_IPROC_UAPI_DTE_H_
+
+#include <linux/ioctl.h>
+
+struct dte_client_data {
+	unsigned int client;
+	unsigned int enable;
+	unsigned int divider;
+	unsigned int both_edge;
+};
+
+struct dte_timestamp {
+	unsigned int client;
+	struct timespec ts;
+};
+
+struct dte_client_list {
+	char name[25];
+	unsigned int div_status; /* divider availability */
+};
+
+#define DTE_IOCTL_BASE          0xFC
+#define DTE_IO(nr)              _IO(DTE_IOCTL_BASE, nr)
+#define DTE_IOR(nr, type)       _IOR(DTE_IOCTL_BASE, nr, type)
+#define DTE_IOW(nr, type)       _IOW(DTE_IOCTL_BASE, nr, type)
+#define DTE_IOWR(nr, type)      _IOWR(DTE_IOCTL_BASE, nr, type)
+
+#define DTE_IOCTL_SET_TIME          DTE_IOW(0x10, struct timespec)
+#define DTE_IOCTL_GET_TIME          DTE_IOR(0x11, struct timespec)
+#define DTE_IOCTL_ADJ_TIME          DTE_IOW(0x12, int64_t)
+#define DTE_IOCTL_ADJ_FREQ          DTE_IOW(0x13, int32_t)
+#define DTE_IOCTL_GET_FREQ_ADJ      DTE_IOR(0x14, int32_t)
+
+#define DTE_IOCTL_ENABLE_CLIENT_TS  DTE_IOW(0x20, struct dte_client_data)
+#define DTE_IOCTL_GET_TIMESTAMP     DTE_IOWR(0x21, struct dte_timestamp)
+
+#define DTE_IOCTL_DISPLAY_DRV_INF   DTE_IO(0x30)
+#define DTE_IOCTL_GET_NUM_OF_CLIENT DTE_IOR(0x31, uint32_t)
+#define DTE_IOCTL_GET_CLIENT_LIST   DTE_IOR(0x32, struct dte_client_list *)
+
+#endif
